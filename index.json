[{"content":"Remember that time you needed a widget that Android doesn\u0026rsquo;t provide out of the box? Maybe a circular progress bar that looks like a pizza being eaten? Well, grab your favorite caffeinated beverage, because we\u0026rsquo;re about to dive into the world of custom views!\nWhy Create Custom Views? Sometimes the standard Android widgets just don\u0026rsquo;t cut it. Maybe you need:\nA special animation effect A unique user interaction That perfect design your UI/UX team dreamed up To show off to your coworkers (hey, we\u0026rsquo;ve all been there) The Basics: Anatomy of a Custom View Here\u0026rsquo;s a simple custom view that draws a circle that changes color when touched:\nclass ColorChangeCircleView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0 ) : View(context, attrs, defStyleAttr) { private val paint = Paint(Paint.ANTI_ALIAS_FLAG) private var currentColor = Color.BLUE init { // Enable touch events isClickable = true } override fun onDraw(canvas: Canvas) { super.onDraw(canvas) // Get the center and radius val centerX = width / 2f val centerY = height / 2f val radius = min(width, height) / 3f // Draw the circle paint.color = currentColor canvas.drawCircle(centerX, centerY, radius, paint) } override fun onTouchEvent(event: MotionEvent): Boolean { when (event.action) { MotionEvent.ACTION_DOWN -\u0026gt; { // Change color randomly currentColor = Color.rgb( Random.nextInt(256), Random.nextInt(256), Random.nextInt(256) ) invalidate() // Redraw the view return true } } return super.onTouchEvent(event) } } Making It Configurable Nobody likes hardcoded values. Let\u0026rsquo;s make our view configurable through XML:\n// Add these at the top of your class private var circleRadius = 0f private var defaultColor = Color.BLUE init { // Parse attributes context.theme.obtainStyledAttributes( attrs, R.styleable.ColorChangeCircleView, 0, 0 ).apply { try { circleRadius = getDimension( R.styleable.ColorChangeCircleView_circleRadius, resources.getDimension(R.dimen.default_radius) ) defaultColor = getColor( R.styleable.ColorChangeCircleView_defaultColor, Color.BLUE ) } finally { recycle() } } currentColor = defaultColor } And the corresponding attrs.xml:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;declare-styleable name=\u0026#34;ColorChangeCircleView\u0026#34;\u0026gt; \u0026lt;attr name=\u0026#34;circleRadius\u0026#34; format=\u0026#34;dimension\u0026#34; /\u0026gt; \u0026lt;attr name=\u0026#34;defaultColor\u0026#34; format=\u0026#34;color\u0026#34; /\u0026gt; \u0026lt;/declare-styleable\u0026gt; \u0026lt;/resources\u0026gt; Performance Tips (Because Nobody Likes Janky UIs) Avoid Object Creation in onDraw(): // BAD override fun onDraw(canvas: Canvas) { val paint = Paint() // Don\u0026#39;t do this! canvas.drawCircle(...) } // GOOD private val paint = Paint() // Create once in initialization override fun onDraw(canvas: Canvas) { canvas.drawCircle(...) } Use Hardware Acceleration: android:hardwareAccelerated=\u0026#34;true\u0026#34; A Real-World Example: Custom Progress View Here\u0026rsquo;s a more practical example - a custom progress view that fills up like a battery:\nclass BatteryProgressView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0 ) : View(context, attrs, defStyleAttr) { private var progress = 0f private val paint = Paint(Paint.ANTI_ALIAS_FLAG) private val rect = RectF() fun setProgress(value: Float) { progress = value.coerceIn(0f, 100f) invalidate() } override fun onDraw(canvas: Canvas) { super.onDraw(canvas) // Draw battery outline paint.style = Paint.Style.STROKE paint.color = Color.GRAY rect.set(0f, 0f, width.toFloat(), height.toFloat()) canvas.drawRect(rect, paint) // Draw battery level paint.style = Paint.Style.FILL paint.color = when { progress \u0026lt; 20f -\u0026gt; Color.RED progress \u0026lt; 50f -\u0026gt; Color.YELLOW else -\u0026gt; Color.GREEN } val levelWidth = (width * (progress / 100f)) rect.set(0f, 0f, levelWidth, height.toFloat()) canvas.drawRect(rect, paint) } } Conclusion Custom views are like cooking - start with the basic recipe, then add your own flavors. Don\u0026rsquo;t be afraid to experiment, but always keep performance in mind. Your users (and the Android UI thread) will thank you!\nStay tuned for more Android development adventures! Next time, we might tackle custom ViewGroups - because why stop at custom views when you can create entire custom layouts? ðŸ˜ˆ\n","permalink":"http://localhost:1313/posts/custom-views/","summary":"Remember that time you needed a widget that Android doesn\u0026rsquo;t provide out of the box? Maybe a circular progress bar that looks like a pizza being eaten? Well, grab your favorite caffeinated beverage, because we\u0026rsquo;re about to dive into the world of custom views!\nWhy Create Custom Views? Sometimes the standard Android widgets just don\u0026rsquo;t cut it. Maybe you need:\nA special animation effect A unique user interaction That perfect design your UI/UX team dreamed up To show off to your coworkers (hey, we\u0026rsquo;ve all been there) The Basics: Anatomy of a Custom View Here\u0026rsquo;s a simple custom view that draws a circle that changes color when touched:","title":"Custom Views in Android: Because Stock Widgets Are Too Mainstream"},{"content":"Ever found yourself staring at Kotlin coroutines like they\u0026rsquo;re written in ancient hieroglyphics? Fear not, fellow developer! Let\u0026rsquo;s break down these mysterious creatures into bite-sized, digestible pieces that won\u0026rsquo;t give you indigestion.\nWhat Are Coroutines Anyway? Think of coroutines as tiny workers in your code who can pause their work, go grab a coffee, and come back exactly where they left off. Unlike regular functions that must run to completion, coroutines can take breaks without blocking the main thread. Neat, right?\nGetting Started First, you\u0026rsquo;ll need to add the coroutines dependency to your build.gradle:\ndependencies { implementation \u0026#34;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3\u0026#34; } The Basics: Your First Coroutine Let\u0026rsquo;s start with something simple:\nclass MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // Launch a coroutine in the lifecycle scope lifecycleScope.launch { // This is suspended code delay(1000) // Wait for 1 second Log.d(\u0026#34;Coroutines\u0026#34;, \u0026#34;Hello from the future!\u0026#34;) } } } Coroutine Scopes: The Parent-Child Relationship Coroutines have a family tree that would make genealogists proud. Each coroutine has a parent, and when the parent is cancelled, all its children are cancelled too. It\u0026rsquo;s like a really responsible family:\nclass MyViewModel : ViewModel() { init { viewModelScope.launch { // Parent launch { // Child 1 // Some work } launch { // Child 2 // More work } } } } Common Pitfalls (Ask Me How I Know ðŸ˜…) The Infinite Coroutine: Don\u0026rsquo;t forget to cancel your coroutines! I once had a memory leak that took down an entire feature because I forgot this simple rule.\nWrong Context: Running network calls on the main thread is like trying to juggle while riding a unicycle - technically possible, but why would you do that to yourself?\n// DON\u0026#39;T DO THIS lifecycleScope.launch(Dispatchers.Main) { // Heavy network operation api.fetchLargeData() // App freezes, users cry } // DO THIS INSTEAD lifecycleScope.launch(Dispatchers.IO) { // Heavy network operation val data = api.fetchLargeData() withContext(Dispatchers.Main) { // Update UI safely showData(data) } } Real-World Example: Image Loading Here\u0026rsquo;s a practical example of using coroutines for loading images:\nclass ImageLoader { fun loadImage(imageUrl: String, imageView: ImageView) { // Launch in the Main scope but switch to IO for network lifecycleScope.launch { try { val bitmap = withContext(Dispatchers.IO) { URL(imageUrl).openStream().use { BitmapFactory.decodeStream(it) } } // Back on Main thread imageView.setImageBitmap(bitmap) } catch (e: Exception) { // Handle error Log.e(\u0026#34;ImageLoader\u0026#34;, \u0026#34;Failed to load image\u0026#34;, e) } } } } Conclusion Coroutines might seem scary at first, but they\u0026rsquo;re just trying to make our lives easier. Once you get the hang of them, you\u0026rsquo;ll wonder how you ever lived without them. Stay tuned for more adventures in the Kotlin wilderness!\n","permalink":"http://localhost:1313/posts/kotlin-coroutines/","summary":"Ever found yourself staring at Kotlin coroutines like they\u0026rsquo;re written in ancient hieroglyphics? Fear not, fellow developer! Let\u0026rsquo;s break down these mysterious creatures into bite-sized, digestible pieces that won\u0026rsquo;t give you indigestion.\nWhat Are Coroutines Anyway? Think of coroutines as tiny workers in your code who can pause their work, go grab a coffee, and come back exactly where they left off. Unlike regular functions that must run to completion, coroutines can take breaks without blocking the main thread.","title":"Kotlin Coroutines: A Guide for the Perpetually Confused"},{"content":" FlipTimerView - FlipTimerView library for Android developed in Kotlin. http_cyclic_mocks - A Simple and lightweight Dart library for mocking/overriding HTTP responses with Dio. In this library you can add multiple responses for a single route/api endpoint.. ","permalink":"http://localhost:1313/projects/","summary":" FlipTimerView - FlipTimerView library for Android developed in Kotlin. http_cyclic_mocks - A Simple and lightweight Dart library for mocking/overriding HTTP responses with Dio. In this library you can add multiple responses for a single route/api endpoint.. ","title":"Featured Projects"}]