[{"content":"Hey! Let\u0026rsquo;s explore Jetpack Compose and see how it makes Android UI development more enjoyable.\nWhat is Jetpack Compose? Compose is just a different way to build your app\u0026rsquo;s UI. Instead of writing XML layouts and then manipulating them with code, you write Kotlin functions that describe your UI. It\u0026rsquo;s that simple.\nGetting Started First, add these to your build.gradle:\ndependencies { implementation \u0026#34;androidx.compose.ui:ui:1.5.4\u0026#34; implementation \u0026#34;androidx.compose.material:material:1.5.4\u0026#34; implementation \u0026#34;androidx.compose.ui:ui-tooling-preview:1.5.4\u0026#34; } Your First Composable Let\u0026rsquo;s write something simple:\n@Composable fun WelcomeText(name: String) { Text(\u0026#34;Hey $name, welcome to Compose!\u0026#34;) } That\u0026rsquo;s it! The @Composable annotation tells Compose that this function outputs UI elements. You can use it like any regular Kotlin function.\nState: Making Things Interactive State in Compose is just data that can change over time. When it changes, Compose updates your UI automatically:\n@Composable fun Counter() { var count by remember { mutableStateOf(0) } Column(modifier = Modifier.padding(16.dp)) { Text(\u0026#34;You clicked $count times\u0026#34;) Button(onClick = { count++ }) { Text(\u0026#34;Click me\u0026#34;) } } } Modifiers: Styling Your UI Modifiers are like CSS for your composables. They let you change how things look and behave:\n@Composable fun StyledButton( text: String, onClick: () -\u0026gt; Unit ) { Button( onClick = onClick, modifier = Modifier .padding(16.dp) .fillMaxWidth() .height(48.dp) ) { Text(text) } } Common Gotchas to Watch Out For State Reset: Don\u0026rsquo;t declare state outside composable functions: // DON\u0026#39;T do this var count = mutableStateOf(0) // Will reset on recomposition // DO this instead var count by remember { mutableStateOf(0) } Wrong Thread: UI updates must happen on the main thread: // DON\u0026#39;T do this LaunchedEffect(key1 = true) { withContext(Dispatchers.IO) { // UI updates here will crash } } // DO this instead LaunchedEffect(key1 = true) { val data = withContext(Dispatchers.IO) { // Do background work } // Update UI on main thread } Real World Example: A User Card Here\u0026rsquo;s how you might build a user profile card:\n@Composable fun UserCard(user: User) { Card( modifier = Modifier .padding(16.dp) .fillMaxWidth() ) { Row( modifier = Modifier.padding(16.dp), verticalAlignment = Alignment.CenterVertically ) { // Avatar AsyncImage( model = user.avatarUrl, contentDescription = \u0026#34;Profile picture\u0026#34;, modifier = Modifier .size(50.dp) .clip(CircleShape) ) Spacer(Modifier.width(16.dp)) // User info Column { Text( text = user.name, style = MaterialTheme.typography.subtitle1 ) Text( text = user.email, style = MaterialTheme.typography.body2, color = MaterialTheme.colors.onSurface.copy(alpha = 0.6f) ) } } } } Why Use Compose? Less Code: No more XML layouts or view binding Preview Support: See your UI changes instantly in Android Studio Reusable Components: Easy to create and share UI components State Management: Automatic UI updates when data changes Useful Tips Break down large composables into smaller ones Use previews for quick iteration Keep state at the appropriate level Use appropriate scopes for side effects Conclusion Compose might feel different at first, but it makes UI development much more straightforward once you get used to it. Start with small components, understand how state works, and you\u0026rsquo;ll be building complex UIs in no time.\nDon\u0026rsquo;t forget to check out my other articles!\n","permalink":"https://www.codefright.com/posts/jetpack-compose/","summary":"Hey! Let\u0026rsquo;s explore Jetpack Compose and see how it makes Android UI development more enjoyable.\nWhat is Jetpack Compose? Compose is just a different way to build your app\u0026rsquo;s UI. Instead of writing XML layouts and then manipulating them with code, you write Kotlin functions that describe your UI. It\u0026rsquo;s that simple.\nGetting Started First, add these to your build.gradle:\ndependencies { implementation \u0026#34;androidx.compose.ui:ui:1.5.4\u0026#34; implementation \u0026#34;androidx.compose.material:material:1.5.4\u0026#34; implementation \u0026#34;androidx.compose.ui:ui-tooling-preview:1.5.4\u0026#34; } Your First Composable Let\u0026rsquo;s write something simple:","title":"⚡ Lets Explore Jetpack Compose!"},{"content":"Remember that time you needed a widget that Android doesn\u0026rsquo;t provide out of the box? Maybe a circular progress bar that looks like a pizza being eaten? Well, grab your favorite beverage, because we\u0026rsquo;re about to dive into the world of custom views!\nWhy Create Custom Views? Sometimes the standard Android widgets just don\u0026rsquo;t cut it. Maybe you need:\nA special animation effect A unique user interaction That perfect design your UI/UX team dreamed up The Basics: Anatomy of a Custom View Here\u0026rsquo;s a simple custom view that draws a circle that changes color when touched:\nclass ColorChangeCircleView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0 ) : View(context, attrs, defStyleAttr) { private val paint = Paint(Paint.ANTI_ALIAS_FLAG) private var currentColor = Color.BLUE init { // Enable touch events isClickable = true } override fun onDraw(canvas: Canvas) { super.onDraw(canvas) // Get the center and radius val centerX = width / 2f val centerY = height / 2f val radius = min(width, height) / 3f // Draw the circle paint.color = currentColor canvas.drawCircle(centerX, centerY, radius, paint) } override fun onTouchEvent(event: MotionEvent): Boolean { when (event.action) { MotionEvent.ACTION_DOWN -\u0026gt; { // Change color randomly currentColor = Color.rgb( Random.nextInt(256), Random.nextInt(256), Random.nextInt(256) ) invalidate() // Redraw the view return true } } return super.onTouchEvent(event) } } Understanding the View Lifecycle Measurement and Layout The view lifecycle is crucial for proper rendering. Here\u0026rsquo;s how to handle measurement and layout:\noverride fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) { // Calculate the ideal size of the view based on content val desiredWidth = suggestedMinimumWidth + paddingLeft + paddingRight val desiredHeight = suggestedMinimumHeight + paddingTop + paddingBottom // Reconcile size with any constraints from the parent val finalWidth = resolveSize(desiredWidth, widthMeasureSpec) val finalHeight = resolveSize(desiredHeight, heightMeasureSpec) // Must call this to save the measurements setMeasuredDimension(finalWidth, finalHeight) } override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) { super.onSizeChanged(w, h, oldw, oldh) // Update size-dependent calculations circleRadius = min(w, h) / 3f // Update drawing bounds rect.set( paddingLeft.toFloat(), paddingTop.toFloat(), (w - paddingRight).toFloat(), (h - paddingBottom).toFloat() ) } State Management Always handle configuration changes and state restoration:\noverride fun onSaveInstanceState(): Parcelable { val superState = super.onSaveInstanceState() return Bundle().apply { putParcelable(\u0026#34;superState\u0026#34;, superState) putInt(\u0026#34;currentColor\u0026#34;, currentColor) } } override fun onRestoreInstanceState(state: Parcelable?) { val bundle = state as Bundle super.onRestoreInstanceState(bundle.getParcelable(\u0026#34;superState\u0026#34;)) currentColor = bundle.getInt(\u0026#34;currentColor\u0026#34;) invalidate() } Making It Configurable Let\u0026rsquo;s make our view configurable through XML with various attribute types:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;declare-styleable name=\u0026#34;ColorChangeCircleView\u0026#34;\u0026gt; \u0026lt;attr name=\u0026#34;circleRadius\u0026#34; format=\u0026#34;dimension\u0026#34; /\u0026gt; \u0026lt;attr name=\u0026#34;defaultColor\u0026#34; format=\u0026#34;color\u0026#34; /\u0026gt; \u0026lt;attr name=\u0026#34;shapeStyle\u0026#34; format=\u0026#34;enum\u0026#34;\u0026gt; \u0026lt;enum name=\u0026#34;filled\u0026#34; value=\u0026#34;0\u0026#34; /\u0026gt; \u0026lt;enum name=\u0026#34;stroke\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;/attr\u0026gt; \u0026lt;attr name=\u0026#34;strokeWidth\u0026#34; format=\u0026#34;dimension\u0026#34; /\u0026gt; \u0026lt;attr name=\u0026#34;enableAnimation\u0026#34; format=\u0026#34;boolean\u0026#34; /\u0026gt; \u0026lt;/declare-styleable\u0026gt; \u0026lt;/resources\u0026gt; And the corresponding Kotlin implementation:\ninit { context.theme.obtainStyledAttributes( attrs, R.styleable.ColorChangeCircleView, 0, 0 ).apply { try { circleRadius = getDimension( R.styleable.ColorChangeCircleView_circleRadius, resources.getDimension(R.dimen.default_radius) ) defaultColor = getColor( R.styleable.ColorChangeCircleView_defaultColor, Color.BLUE ) shapeStyle = getInt( R.styleable.ColorChangeCircleView_shapeStyle, SHAPE_STYLE_FILLED ) strokeWidth = getDimension( R.styleable.ColorChangeCircleView_strokeWidth, resources.getDimension(R.dimen.default_stroke_width) ) enableAnimation = getBoolean( R.styleable.ColorChangeCircleView_enableAnimation, false ) } finally { recycle() } } currentColor = defaultColor } Advanced Touch Handling Implement sophisticated touch interactions using GestureDetector:\nclass ColorChangeCircleView : View { private val gestureDetector = GestureDetectorCompat(context, object : GestureDetector.SimpleOnGestureListener() { override fun onDown(e: MotionEvent): Boolean = true override fun onSingleTapUp(e: MotionEvent): Boolean { changeColor() return true } override fun onFling( e1: MotionEvent?, e2: MotionEvent, velocityX: Float, velocityY: Float ): Boolean { startSpinAnimation(velocityX) return true } }) override fun onTouchEvent(event: MotionEvent): Boolean { return gestureDetector.onTouchEvent(event) || super.onTouchEvent(event) } } Animation Integration Add smooth animations to your custom view:\nprivate fun startColorAnimation(newColor: Int) { ValueAnimator.ofArgb(currentColor, newColor).apply { duration = 300 interpolator = FastOutSlowInInterpolator() addUpdateListener { animator -\u0026gt; currentColor = animator.animatedValue as Int invalidate() } start() } } Accessibility Considerations Make your custom view accessible to all users:\ninit { // Set content description contentDescription = context.getString(R.string.color_circle_description) // Enable accessibility events importantForAccessibility = IMPORTANT_FOR_ACCESSIBILITY_YES } override fun onInitializeAccessibilityNodeInfo(info: AccessibilityNodeInfo) { super.onInitializeAccessibilityNodeInfo(info) info.className = Button::class.java.name info.isClickable = true info.addAction(AccessibilityNodeInfo.ACTION_CLICK) } Performance Tips Avoid Object Creation in onDraw() // BAD override fun onDraw(canvas: Canvas) { val paint = Paint() // Don\u0026#39;t do this! canvas.drawCircle(...) } // GOOD private val paint = Paint() // Create once in initialization override fun onDraw(canvas: Canvas) { canvas.drawCircle(...) } Use Hardware Acceleration android:hardwareAccelerated=\u0026#34;true\u0026#34; Optimize Invalidation // Only invalidate the necessary area invalidate(left, top, right, bottom) // Use post for thread-safe invalidation postInvalidate() Debugging Tips Debug draw mode: override fun onDraw(canvas: Canvas) { super.onDraw(canvas) if (BuildConfig.DEBUG) { paint.style = Paint.Style.STROKE paint.color = Color.RED canvas.drawRect(0f, 0f, width.toFloat(), height.toFloat(), paint) } } Log measurements: override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) { super.onMeasure(widthMeasureSpec, heightMeasureSpec) if (BuildConfig.DEBUG) { val widthMode = MeasureSpec.getMode(widthMeasureSpec) val widthSize = MeasureSpec.getSize(widthMeasureSpec) Log.d(TAG, \u0026#34;Width Mode: ${getModeString(widthMode)}, Size: $widthSize\u0026#34;) } } Testing Custom Views Here\u0026rsquo;s a basic test setup:\n@RunWith(AndroidJUnit4::class) class ColorChangeCircleViewTest { private lateinit var view: ColorChangeCircleView @Before fun setup() { view = ColorChangeCircleView( InstrumentationRegistry.getInstrumentation().targetContext ) } @Test fun testColorChange() { val initialColor = view.getCurrentColor() view.performClick() assertNotEquals(initialColor, view.getCurrentColor()) } } A Real-World Example: Custom Progress View Here\u0026rsquo;s a more practical example - a custom progress view that fills up like a battery:\nclass BatteryProgressView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0 ) : View(context, attrs, defStyleAttr) { private var progress = 0f private val paint = Paint(Paint.ANTI_ALIAS_FLAG) private val rect = RectF() fun setProgress(value: Float) { progress = value.coerceIn(0f, 100f) invalidate() } override fun onDraw(canvas: Canvas) { super.onDraw(canvas) // Draw battery outline paint.style = Paint.Style.STROKE paint.color = Color.GRAY rect.set(0f, 0f, width.toFloat(), height.toFloat()) canvas.drawRect(rect, paint) // Draw battery level paint.style = Paint.Style.FILL paint.color = when { progress \u0026lt; 20f -\u0026gt; Color.RED progress \u0026lt; 50f -\u0026gt; Color.YELLOW else -\u0026gt; Color.GREEN } val levelWidth = (width * (progress / 100f)) rect.set(0f, 0f, levelWidth, height.toFloat()) canvas.drawRect(rect, paint) } } Resources for Further Learning Android Developer Documentation on Custom Views Android Graphics Architecture Material Design Guidelines Conclusion Custom views are like cooking - start with the basic recipe, then add your own flavors. Don\u0026rsquo;t be afraid to experiment, but always keep performance in mind. Your users (and the Android UI thread) will thank you!\nStay tuned for more Android development articles!\n","permalink":"https://www.codefright.com/posts/custom-views/","summary":"Remember that time you needed a widget that Android doesn\u0026rsquo;t provide out of the box? Maybe a circular progress bar that looks like a pizza being eaten? Well, grab your favorite beverage, because we\u0026rsquo;re about to dive into the world of custom views!\nWhy Create Custom Views? Sometimes the standard Android widgets just don\u0026rsquo;t cut it. Maybe you need:\nA special animation effect A unique user interaction That perfect design your UI/UX team dreamed up The Basics: Anatomy of a Custom View Here\u0026rsquo;s a simple custom view that draws a circle that changes color when touched:","title":"⚡ Guide to Custom Views in Android"},{"content":"Hey! Lets explore Kotlin Coroutines in this post.\nWhat Are Coroutines? Think of coroutines as tiny workers in your code who can pause their work, go grab a coffee, and come back exactly where they left off. Unlike regular functions that must run to completion, coroutines can take breaks without blocking the main thread.\nWhen a coroutine \u0026ldquo;takes a break,\u0026rdquo; it\u0026rsquo;s typically doing one of several things:\nWaiting for I/O operations to complete (like reading from a file or making a network request) Yielding control to allow other coroutines to run Waiting for a timer or delay to expire Waiting for data from another coroutine or for some condition to be met The key point is that during these \u0026ldquo;breaks,\u0026rdquo; the coroutine isn\u0026rsquo;t actually consuming CPU resources. Instead, it\u0026rsquo;s in a suspended state, and the program can do other useful work.\nGetting Started First, you\u0026rsquo;ll need to add the coroutines dependency to your build.gradle:\ndependencies { implementation \u0026#34;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.10.1\u0026#34; } The Basics: Your First Coroutine Let\u0026rsquo;s start with something simple:\nclass MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // Launch a coroutine in the lifecycle scope lifecycleScope.launch { // This is suspended code delay(1000) // Wait for 1 second Log.d(\u0026#34;Coroutines\u0026#34;, \u0026#34;Hello from the future!\u0026#34;) } } } Understanding Dispatchers: Where Your Coroutines Run Think of dispatchers as different workspaces for your coroutines. Just like how you wouldn\u0026rsquo;t do heavy lifting in a library or read a book at a gym, different coroutines need different environments:\nsuspend fun showHowDispatchersWork() { // For CPU-intensive tasks (like sorting lists, parsing JSON) withContext(Dispatchers.Default) { val hugelist = (1..1000000).toList().shuffled() hugelist.sorted() // Heavy computation } // For network/disk operations withContext(Dispatchers.IO) { // Reading files, making API calls val data = URL(\u0026#34;https://api.example.com\u0026#34;).readText() } // For UI updates withContext(Dispatchers.Main) { binding.textView.text = \u0026#34;Updated!\u0026#34; } } Coroutine Builders: Different Ways to Launch Coroutines come with different \u0026ldquo;builders\u0026rdquo; - think of them as different tools for different jobs:\nclass CoroutineDemo { fun showDifferentBuilders() { // Fire and forget lifecycleScope.launch { Log.d(\u0026#34;Demo\u0026#34;, \u0026#34;This just runs!\u0026#34;) } // Returns a result val deferred = lifecycleScope.async { delay(1000) \u0026#34;Hello from async!\u0026#34; } // runBlocking - Mainly for testing runBlocking { val result = deferred.await() Log.d(\u0026#34;Demo\u0026#34;, result) } } } Coroutine Scopes: The Parent-Child Relationship Coroutines have a family tree. Each coroutine has a parent, and when the parent is cancelled, all its children are cancelled too. It\u0026rsquo;s like a really responsible family:\nclass MyViewModel : ViewModel() { init { viewModelScope.launch { // Parent launch { // Child 1 // Some work } launch { // Child 2 // More work } } } } The Cool Benefits of Coroutines Why should you fall in love with coroutines? Here\u0026rsquo;s why:\nThey\u0026rsquo;re Light as a Feather: While threads might take 1MB+ of memory, coroutines only need a few bytes. You can run thousands of them without breaking a sweat!\nStructured Concurrency: Coroutines are organized in a way that makes error handling and cancellation much more predictable. When a parent coroutine is cancelled, all its children are automatically cancelled too:\nviewModelScope.launch { try { val userInfo = async { fetchUserInfo() } val userPosts = async { fetchUserPosts() } // Wait for both results displayUserProfile(userInfo.await(), userPosts.await()) } catch (e: Exception) { // Handles errors from both operations! showError(\u0026#34;Oops, something went wrong!\u0026#34;) } } Sequential by Default: Writing async code that looks like sync code is a superpower: // The old way (callbacks) fetchUserData { user -\u0026gt; fetchUserPosts(user.id) { posts -\u0026gt; fetchPostComments(posts[0].id) { comments -\u0026gt; // Welcome to callback hell! } } } // The coroutine way lifecycleScope.launch { val user = fetchUserData() val posts = fetchUserPosts(user.id) val comments = fetchPostComments(posts[0].id) // Clean and simple! } Watch Out For These Gotchas! Here are some common pitfalls to watch out for:\nThe Infinite Coroutine: Don\u0026rsquo;t forget to cancel your coroutines! It could result in memory leaks.\nWrong Context: Running network calls on the main thread is like trying to juggle while riding a unicycle.\n// DON\u0026#39;T DO THIS lifecycleScope.launch(Dispatchers.Main) { // Heavy network operation api.fetchLargeData() // App freezes } // DO THIS INSTEAD lifecycleScope.launch(Dispatchers.IO) { // Heavy network operation val data = api.fetchLargeData() withContext(Dispatchers.Main) { // Update UI safely showData(data) } } The Scope Mixup: Using the wrong scope can lead to memory leaks or crashes: // DON\u0026#39;T: Using GlobalScope is like using a global variable GlobalScope.launch { // This might outlive your activity! } // DO: Use structured concurrency lifecycleScope.launch { // This gets cancelled when your activity does } The Context Switch Confusion: lifecycleScope.launch(Dispatchers.IO) { val data = fetchData() binding.textView.text = data // Crash! Can\u0026#39;t touch UI here withContext(Dispatchers.Main) { binding.textView.text = data // This is the way } } The Exception Escape: Coroutines can be sneaky with exceptions: // DON\u0026#39;T: Silent failure lifecycleScope.launch { throw Exception(\u0026#34;Boom!\u0026#34;) // Gets swallowed } // DO: Handle your exceptions lifecycleScope.launch { try { throw Exception(\u0026#34;Boom!\u0026#34;) } catch (e: Exception) { Log.e(\u0026#34;Error\u0026#34;, \u0026#34;Something went wrong\u0026#34;, e) showErrorToUser(e.message) } } Real-World Examples Image Loading Here\u0026rsquo;s a practical example of using coroutines for loading images:\nclass ImageLoader { fun loadImage(imageUrl: String, imageView: ImageView) { // Launch in the Main scope but switch to IO for network lifecycleScope.launch { try { val bitmap = withContext(Dispatchers.IO) { URL(imageUrl).openStream().use { BitmapFactory.decodeStream(it) } } // Back on Main thread imageView.setImageBitmap(bitmap) } catch (e: Exception) { // Handle error Log.e(\u0026#34;ImageLoader\u0026#34;, \u0026#34;Failed to load image\u0026#34;, e) } } } } Building a Cache+Network Data Fetcher Let\u0026rsquo;s see how coroutines shine in a real-world scenario:\nclass DataRepository { suspend fun fetchUserData(userId: String): User { // Try cache first return withContext(Dispatchers.IO) { try { val cachedUser = database.getUser(userId) if (cachedUser.isUpToDate()) { return@withContext cachedUser } // Cache miss or outdated, fetch from network val freshUser = api.fetchUser(userId) // Update cache in the background launch { database.saveUser(freshUser) } freshUser } catch (e: Exception) { // If everything fails, at least try to return cached data database.getUser(userId) ?: throw e } } } } Conclusion Understanding Coroutines might seem difficult at first, but once you get the hang of them, you\u0026rsquo;ll wonder how you ever lived without them. They provide a powerful way to handle asynchronous operations with clean, readable code that\u0026rsquo;s both efficient and maintainable.\nDon\u0026rsquo;t forget to checkout my other articles!\n","permalink":"https://www.codefright.com/posts/kotlin-coroutines/","summary":"Hey! Lets explore Kotlin Coroutines in this post.\nWhat Are Coroutines? Think of coroutines as tiny workers in your code who can pause their work, go grab a coffee, and come back exactly where they left off. Unlike regular functions that must run to completion, coroutines can take breaks without blocking the main thread.\nWhen a coroutine \u0026ldquo;takes a break,\u0026rdquo; it\u0026rsquo;s typically doing one of several things:\nWaiting for I/O operations to complete (like reading from a file or making a network request) Yielding control to allow other coroutines to run Waiting for a timer or delay to expire Waiting for data from another coroutine or for some condition to be met The key point is that during these \u0026ldquo;breaks,\u0026rdquo; the coroutine isn\u0026rsquo;t actually consuming CPU resources.","title":"⚡ Kotlin Coroutines for the Beginners"},{"content":"Anu S Pillai Android | Kotlin | Flutter\n✉️ anu_icloud@icloud.com | 📍 Bangalore, India\nSummary Experienced Android and Kotlin developer with over 11 years of expertise designing, architecting and developing Android applications, SDKs and library projects. Extensive experience leading teams and delivering high-quality software solutions.\nSuccessfully developed and published over 25 apps on PlayStore, including apps with over 100K downloads, such as South Indian Bank mPassbook, Scootsy (acquired by Swiggy), Revofit (a fitness/lifestyle app backed by Marico), Wellthy Care (a chronic disease management platform, acquired by TruDoc Inc.), and Catch \u0026amp; Win - Howzzattt (a 2D game developed using AndEngine for Toonz Animation India).\nPassionate about learning and mastering new technologies and frameworks independently. Enjoys sharing knowledge through meetups, blogging, and open-source contributions. Would love to explore more of KMM and mobile LLMs.\nExperience Tech Lead - Apps and Frameworks Borqs Software Solutions, Bangalore (2023 - Present)\nLeading a team working on an array of inhouse as well as ODC projects involving Android, Kotlin, Flutter Worked as an Android / Kotlin Tech Consultant for an AAOS - Kotlin project for Qualcomm Inc. Lead a team designing and architecting a Kotlin MQTT Cloud Sync module + Flutter companion app for an overseas Android Automotive project Currently working with Meta Inc. (Facebook) for developing a Flutter based cross-platform desktop project Actively participate in code reviews and project architecture discussions. Conduct internal meetups to upskill and mentor developers Lead Software Developer - Android Wellthy Therapeutics, Bangalore (2021 - 2023)\nArchitected and developed Wellthy app and SDK for Android platform with 100K+ downloads and maintaining \u0026gt;99% weekly crash free users Lead developer responsible for architecting and developing new feature requirements Worked on Improving app user experience and timely bug fixes which resulted in PlayStore rating going up from 3.5 to 4.6 in a year Collaborated with cross-functional teams to design and develop features that met business requirements Led the team to brainstorm and implement code optimizations and features which led to a significant improvement in code reusability, modularity and maintainability Helped the organization to achieve faster development goals by introducing code templates and generators Overlooking the Sprint plans, Task prioritization and ensure timely sprint / task closure Maintaining the team\u0026rsquo;s performance scorecards, BvA analysis, setting and tracking quarterly goals Lead the Wellthy SDK development team to develop and document SDK based on Wellthy Platform Senior Software Developer - Android Wellthy Therapeutics, Bangalore (2017 - 2021)\nArchitected and developed Wellthy app for Android platform Developed and maintained mobile applications using Kotlin language Bug tracking / Fixing and timely release and team management Write and review test cases Senior Application Developer Scootsy (Acquired by Swiggy), Mumbai (2014 - 2017)\nLed the team developing Android Apps like Scootsy, Revofit, Scootsy VMS from scratch Developed and maintained mobile applications using Java Collaborated with cross-functional teams to design and develop mobile applications Developer responsible for coordinating the project. Followed Agile / Scrum development methodology Junior Android Developer Simrge, Trivandrum (2013 - 2014)\nDeveloped Android Apps like mParking Dubai, Howzzattt 2D Game using AndEngine, SIB mPassbook (Android + Blackberry), iCRM for vTiger First Android Hire. Followed Agile development Education Bachelor of Information Technology Anna University, Chennai (2008 - 2012)\nSkills Languages Kotlin (Proficient) Java (Proficient) Flutter / Dart (Advanced) KMM (Beginner) Python (Intermediate) Links Stack Overflow LinkedIn GitHub Twitter Blog Notable Contributions WELLTHY CARE (WELLTHY THERAPEUTICS) View on Play Store\nWellthy Care is the digital health coach that will help you manage diabetes, chronic kidney disease (CKD) and other such chronic conditions.\nTechnologies used: Kotlin, MVVM, Hilt, Coroutines, Retrofit with RxJava for API calls, Realm, Espresso, JUnit, AWS Mqtt SCOOTSY (ACQUIRED BY SWIGGY) View on Play Store\nScootsy is an intra-city delivery service in Mumbai that delivers from the best restaurants, food stores, book shops, toy stores, fashion outlets, gift shops, sport stores and more.\nTechnologies used: Java, SQLite, Retrofit, Socket.IO, Firebase, GraphQL SOUTH INDIAN BANK M-PASSBOOK (ANDROID / WINDOWS /BLACKBERRY) View Details\nIndia\u0026rsquo;s one of the first mobile passbook app. Track your SIB account transactions on the go. Developed for South Indian Bank. Developed for Android and Windows. Ported to Blackberry.\nTechnologies used: Java, SQLite, Retrofit, C# (for Windows app) And Many More!\n","permalink":"https://www.codefright.com/resume/","summary":"Anu S Pillai Android | Kotlin | Flutter\n✉️ anu_icloud@icloud.com | 📍 Bangalore, India\nSummary Experienced Android and Kotlin developer with over 11 years of expertise designing, architecting and developing Android applications, SDKs and library projects. Extensive experience leading teams and delivering high-quality software solutions.\nSuccessfully developed and published over 25 apps on PlayStore, including apps with over 100K downloads, such as South Indian Bank mPassbook, Scootsy (acquired by Swiggy), Revofit (a fitness/lifestyle app backed by Marico), Wellthy Care (a chronic disease management platform, acquired by TruDoc Inc.","title":""},{"content":"Library Projects FlipTimerView A customizable flip animation timer library for Android, developed in Kotlin.\nSimple flip animation with customizable duration Support for days, hours, minutes and seconds http_cyclic_mocks A lightweight Dart library for mocking HTTP responses with Dio. Mock Multiple Responses for single route / endpoint.\nSupport for multiple responses per endpoint Cyclic response patterns Easy integration with existing Dio setup Perfect for testing and development Hobby Projects KinderScript [Work in Progress] A simple terminal based child-friendly programming language for learning coding basics. Developed completely in Kotlin.\nSimple syntax for kids Built for educational purposes ","permalink":"https://www.codefright.com/projects/","summary":"Library Projects FlipTimerView A customizable flip animation timer library for Android, developed in Kotlin.\nSimple flip animation with customizable duration Support for days, hours, minutes and seconds http_cyclic_mocks A lightweight Dart library for mocking HTTP responses with Dio. Mock Multiple Responses for single route / endpoint.\nSupport for multiple responses per endpoint Cyclic response patterns Easy integration with existing Dio setup Perfect for testing and development Hobby Projects KinderScript [Work in Progress] A simple terminal based child-friendly programming language for learning coding basics.","title":"Featured Projects"}]